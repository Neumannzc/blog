---
title: 数据一致性
date: 2024-05-18
icon: snowman
category:
  - redis
tag:
  - redis的概念
order: 400
---

缓存中的数据源来自于数据库，而数据库的数据是会发生变化的。

如果数据库中的数据发生变化，而缓存却没有同步，就会产生一致性问题，即 **数据库** 中的数据和 **缓存** 中的数据不一样

<!-- more -->

## 一、缓存更新策略

- 向redis中插入太多数据时，就会导致缓存中的数据过多，所以redis就会对部分数据进行更新，也叫淘汰。

名称 | 说明 | 一致性 | 维护成本
-- | -- | -- | --
内存淘汰 | 不用自己维护，利用redis的内存淘汰机制，当内存不足时自动淘汰部分数据，下次查询时更新缓存 | 差 | 无
超时剔除 | 给缓存数据添加TTL时间，到期后自动删除缓存，下次查询时更新缓存 | 一般 | 低
主动更新 | 编写业务逻辑，再修改数据库的同时，更新缓存 | 好 | 高

- 同对于不同的业务场景，即不同的数据一致性要求，可以使用不同的策略

场景 | 策略
-- | --
低一致性需求 | 使用内存淘汰机制
高一致性需求 | 主动更新，并以超时剔除作为兜底方案

## 二、解决方案

### 2.1、目前已有方案

名称 | 操作者 | 描述
-- | -- | --
Cache Aside Pattern | 缓存调用者 | 缓存的使用者，在更新数据库的同时更新缓存
Read/Write Through Pattern | 系统 | 缓存与数据库整合为一个服务，由服务来维护一致性。缓存的使用者调用该服务，无需关心缓存一致性问题
Write Behind Caching Pattern | 其他线程 | 调用者只操作缓存，由其他线程异步的将缓存数据持久化到数据库，保证最终一致

### 2.2、存在的问题

对于数据一致性，想要讨论出解决方案，应该先解决以下三个问题

- 删除缓存还是更新缓存

- 如何保证缓存与数据库的操作同时成功或失败

- 先操作缓存还是先操作数据库

### 2.3、问题分析

- 对于删除缓存还是更新缓存
  - 更新缓存：每次更新数据库都更新缓存，无效写操作较多
  - 删除缓存：更新数据库时让缓存失效，查询时再更新缓存

- 对于如何保证缓存与数据库的操作同时成功或失败
  - 单体系统：将缓存与数据库操作放在一个事务
  - 分布式系统：利用TCC等分布式事务方案

- 对于先操作缓存还是先操作数据库
  - 先删除缓存，再操作数据库：当两个线程并发访问时，会有如下情况的发生
    1. 线程1先来，把缓存删除；
    2. 线程2开始执行，在缓存中查询不到数据时，会查询数据库后把数据放入缓存；
    3. 线程1更新数据库

  - 先操作数据库，再删除缓存：这种情况下也存在线程穿插的情况，但是发生的概率低，因为需要满足条件
    1. 在缓存过期的一瞬间，有一个线程进行查询操作
    2. 修改缓存慢于修改数据库

![1653323595206](/assets/images/1653323595206.png)

### 2.4、结论

问题 | 采用 | 不采用
-- | -- | --
删除缓存还是更新缓存 | 删除缓存 | 更新缓存
保证缓存与数据库的操作同时成功或失败 | 开启事务 | 
先操作缓存还是先操作数据库 | 先操作数据库，再操作缓存 | 先操作缓存，再操作数据库