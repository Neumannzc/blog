---
title: 缓存击穿、穿透、雪崩
date: 2024-05-28
icon: snowman
category:
  - redis
tag:
  - redis的概念
order: 410
---

在使用缓存过程中，常见的三大问题，缓存击穿、缓存穿透、缓存雪崩，是什么？如何解决？

<!-- more -->

## 一、缓存击穿

### 1.1、概念

缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。

### 1.2、问题分析

![1653328022622](/assets/images/1653328022622.png)

缓存穿透现象的核心问题在于请求中使用的key在Redis缓存中无法找到相应的值。

这与缓存击穿的情形有本质的不同，后者通常涉及一个有效key的过期失效。在缓存穿透的情况下，传入的key在Redis中根本就不存在。如果黑客故意发送大量不存在的key的请求，这会导致数据库遭受巨大的查询压力，可能会严重威胁到系统的正常运行。

因此，在日常开发实践中，对请求参数进行严格的校验是至关重要的。对于那些非法或明显不可能存在的key，系统应该立即返回一个错误提示，而不是让这些请求到达数据库层面。这样不仅可以提升系统的安全性，还能够维护数据库的稳定性和性能。

### 1.3、解决方案

方案 | 优点 | 缺点
-- | -- | --
互斥锁 | 1、保证了互斥性，数据一致<br>2、实现简单<br>3、没有额外内存消耗 | 1、可能会发生死锁问题<br>2、只能串行执行，性能会受影响
逻辑过期 | 线程读取过程中不需要等待，性能好 | 1、不保证数据一致性<br>2、有额外的内存消耗<br>3、实现复杂


### 1.4、互斥锁

#### 实现原理：

![1653328288627](/assets/images/1653328288627.png)

相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是：
1. 进行查询之后，如果从缓存没有查询到数据，则进行互斥锁的获取
2. 获取互斥锁后，判断是否获得到了锁，如果没有获得到，则休眠，过一会再进行尝试，直到获取到锁为止，才能进行查询
3. 如果获取到了锁的线程，再去进行查询，查询后将数据写入redis，再释放锁，返回数据

简单来说就是 利用互斥锁就能保证只有一个线程去执行操作数据库的逻辑，防止缓存击穿

#### 实现思路：

![1653357860001](/assets/images/1653357860001.png)

利用redis的setnx方法来表示获取锁，该方法含义是redis中如果没有这个key，则插入成功，返回1，在stringRedisTemplate中返回true， 如果有这个key则插入失败，则返回0，在stringRedisTemplate返回false，我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程。

### 1.5、逻辑过期

#### 实现原理：

![1653328663897](/assets/images/1653328663897.png)

当用户开始查询redis时
1. 判断是否命中，如果没有命中则直接返回空数据，不查询数据库
2. 一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回redis中的数据
3. 如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。

#### 实现思路

![1653360308731](/assets/images/1653360308731.png)

新建一个实体类，类中包含 数据`data` 和 逻辑过期时间`expireTime`，同时需要进行缓存预热（项目启动前或项目启动时，把数据库中的数据加载到缓存中）

## 二、缓存穿透

### 2.1、概念
缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。

### 2.2、问题分析

核心问题在于，一旦某个热门的key失效，便会导致密集的并发请求直接涌向数据库。

因此，解决方案需从两个方向着手：首先，考虑对热点key不设置过期时间以保持其持久有效；其次，探索降低数据库所承受的请求量的方法，以减轻其压力。

### 2.3、解决方案

方法 | 优点 | 缺点
-- | -- | --
缓存空对象 | 实现简单，维护方便 | 1、额外的内存消耗<br>2、可能造成短期的不一致
布隆过滤 | 内存占用较少，没有多余key | 1、实现复杂<br>2、存在误判可能

也可以从配置 和 设计层面进行预防

- 增强id的复杂度，避免被猜测id规律
- 做好数据的基础格式校验
- 加强用户权限校验
- 做好热点参数的限流

### 2.4、缓存空对象

![1653327124561](/assets/images/1653327124561.png)

当出现Redis查不到数据，数据库也查不到数据的情况，我们就把这个key保存到Redis中，设置value=""或"null"，并设置其一个较短的过期时间，后面再出现查询这个key的请求的时候，直接返回null，就不需要再查询数据库了。

### 2.5、布隆过滤

![1653326156516](/assets/images/1653326156516.png)

布隆过滤器提供一种高效的概率型检测机制，用于判断一个元素是否 **可能** 在一个集合内。

它的工作原理是，当布隆过滤器断言某个键（key）**不存在** 时，这个结论是 **绝对可靠** 的；但当它认为某个键 **存在** 时，只表示有 **很高的可能性** 确实存在，尽管有一定的误判几率。

为了缓解缓存穿透的问题，我们可以在Redis缓存层之前部署一道布隆过滤器的防线。将数据库中所有的键导入布隆过滤器中，这样在任何查询到达Redis之前，系统会首先检查该查询的键是否在布隆过滤器中。如果键在布隆过滤器中不存在，那么查询将不会继续前往数据库，而是直接返回结果，以此避免对数据库的不必要访问和潜在的查询压力。

通过这样的布隆过滤器前置筛查，我们不仅保护了数据库免受不存在的键的查询压力，还确保了整体系统的性能稳定，即使在高并发查询的环境下也能有效地运作。

## 三、缓存雪崩

### 3.1、概念

缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。

### 3.2、问题分析

![1653327884526](/assets/images/1653327884526.png)

造成缓存雪崩的关键在于同一时间的大规模的key失效，为什么会出现这个问题，主要有两种可能：第一种是Redis宕机，第二种可能就是采用了相同的过期时间。

### 3.3、过期时间随机

在设置失效时间的时候加上一个随机值，比如1-5分钟随机。这样就可以避免了由于使用相同的过期时间导致在某一时刻大量key过期引发的缓存雪崩问题。

### 3.4、使用熔断机制           

当系统流量达到预定的极限时，为避免对数据库造成过大压力，我们将自动显示“系统繁忙”提示。这样做可以确保至少有一部分用户能够顺畅地使用我们的服务。对于未能即时访问的用户，只要多刷新几次，也是可以获得正常访问的。

### 3.5、缓存预热  

缓存预热是一种关键技术，它在系统启动前预先加载关键数据到缓存中，以减少系统上线时对后端数据库的冲击。

由于新上线的系统缓存是空的，如果没有预热过程，大量并发请求将直接访问数据库，极有可能在系统上线初期导致服务崩溃。因此，通过在系统上线之前将高频率访问的数据从数据库加载到Redis等缓存系统中，可以确保用户请求首先由缓存服务处理，从而减轻数据库的压力。

实施缓存预热通常涉及编写批处理任务，这些任务可以在系统启动期间执行，或者通过定时任务定期去执行。定期执行更能保证数据的实时性，但是，同样会耗费系统的部分性能，尤其是在数据量大的时候。所以，具体选择如何进行预热数据，还是需要综合考虑预热数据量的大小以及预热数据更新的是否频繁等因素。

### 3.6、redis集群

保证Redis缓存的高可用，防止Redis宕机导致缓存雪崩的问题。可以使用主从+ 哨兵，Redis集群来避免单个Redis服务器宕机导致整个缓存直接失效。

### 3.7、多级缓存

通过实施多级缓存策略，我们可以优化系统的性能并降低因缓存失效导致的风险。在这种策略中，本地进程内的缓存充当第一级缓存，而Redis则作为第二级远程缓存。每一级缓存都设定有独立且差异化的超时时间，这样的设计确保了即使一级缓存的数据过期或被清除，仍能有二级或其他级别的缓存来提供数据支持。这种层级化的缓存机制为系统提供了额外的弹性层，当一层缓存遇到问题时，其他层级能够起到“安全网”的作用，从而可以有效避免雪崩现象。

### 3.8、互斥锁

这个和缓存击穿比较类似 ，都是通过互斥锁来控制读数据写缓存的线程数量，这样就避免大量请求同时击中数据库。同样，这样虽然可以避免大量key同时失效导致的缓存雪崩问题。但是，同样性能也会因为加锁的原因受到影响。如果，系统对吞吐量要求不高的情况下，这种方式其实还是不错的。因为它即解决了缓存击穿的问题，也解决了缓存雪崩的问题。可谓一举两得。